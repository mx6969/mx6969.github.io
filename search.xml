<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql索引</title>
      <link href="/post/f79dc38d.html"/>
      <url>/post/f79dc38d.html</url>
      
        <content type="html"><![CDATA[<p>什么是事务？<br>事务可以使一组操作要么全部成功，要么全部失败。<br>事务的目的是为了保证数据的最终一致性。</p><p>数据库事务需要存储引擎的支持而 MySQL的默认存储引擎InnoDB就支持事务。<br>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT&#x3D;0，用来禁止使用当前会话的自动提交。</p><p>事务的特性<br>事务的特性也就是我们常说的 ACID模型</p><p>原子性（Atomicity）：当前事务的操作要么同时成功，要么同时失败。原子性由undo log日志来保证（记载着数据修改前的信息）。<br>一致性（Consistency）：一致性可以理解为我们使用事务的目的，而隔离性、原子性、持久性均是为了保障一致性的手段，保证一致性还需要由应用程序代码来保证。<br>隔离性（Isolation）：在事务并发执行时，他们内部的操作不能互相干扰。如果多个事务可以同时操作一个数据，就会产生脏读、不可重复读、幻读的问题。<br>持久性（Durability）：一旦提交了事务，它对数据库的改变就应该是永久性的。说白了就是，它会将数据库持久化在硬盘上。<br>并发事务中的3个问题<br>脏读：事务A 读取到了另一个事务B 未提交的数据（事务B 可能会进行回滚操作），从而导致事务A 读取了一个不存在的脏数据。<br>不可重复读：在同一个事务中，同一个查询在不同的时间得到了不同的结果。例如事务在 T1读取到了某一行数据，在 T2时间重新读取这一行的时候，这一行的数据已经发生修改，所以再次读取时得到了一个和 T1查询时不同的结果。<br>幻读：MySQL对幻读的定义如下：The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row. 翻译为中文是：同一个查询在不同时间得到了不同的结果，这就是事务中的幻读问题。例如，一个 SELECT 被执行了两次，但是第二次返回了第一次没有返回的一行，那么这一行就是一个“幻像”行。（幻读指的是范围查询）<br>为了解决这些问题又产生了隔离级别</p><p>事务的四种隔离级别<br>读未提交（read uncommit）：又叫未提交读，该隔离级别因为可以读取到其他事务中未提交的数据（而未提交的数据可能会发生回滚），因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读。<br>读已提交（read commit）：又叫提交读，该隔离级别的事务能读取到已经提交的事务的数据，因此它不会有脏读的问题，但是由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同SQL查询中，可能会得到不同的结果，这种现象叫做不可重复读。<br>可重复读（repeatable read）：InnoDB默认的事务隔离级别，可重复读可以解决“不可重复读”的问题，但还存在幻读的问题。<br>串行化（serializable）：也叫序列化，事务的最高级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读的问题，但因为执行效率低，所以真正使用的场景不多。<br>不同的隔离级别对事务之间的隔离性是不一样的（级别越高事务的隔离性越好，但是性能就越低），而隔离性是由MySQL的各种锁来实现的，只是它屏蔽了加锁的细节。</p><p>各隔离级别对应的问题：</p><p>隔离级别脏读不可重复读幻读<br>读未提交（read uncommit）√√√<br>读已提交（read commit）×√√<br>可重复读（repeatable read）××√<br>串行化（serializable）×××<br>MySQL通过MVCC（多版本并发控制）解决了幻读问题</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试复盘</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<h1 id="面试复盘"><a href="#面试复盘" class="headerlink" title="面试复盘"></a>面试复盘</h1><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="简单的介绍一下自己？"><a href="#简单的介绍一下自己？" class="headerlink" title="简单的介绍一下自己？"></a>简单的介绍一下自己？</h3><p>面试官你好，我是..，毕业于…的一所本科院校，…学校，专业是计算机科学与技术，我自己在学校有自学Java相关的知识，包括Spring等开源框架， mysql，redis方面在做项目的时候也有用到，还有es和kafka也进行过简单的实操。自己对 …方面比较擅长，开发中用的比较多。</p><h3 id="用一句话简述你觉得项目当时你做的比较有价值得一提的点？"><a href="#用一句话简述你觉得项目当时你做的比较有价值得一提的点？" class="headerlink" title="用一句话简述你觉得项目当时你做的比较有价值得一提的点？"></a>用一句话简述你觉得项目当时你做的比较有价值得一提的点？</h3><p>项目中使用了kafka来进行异步处理，还使用了redis来提高项目的项目的整体性能</p><h3 id="kafka在这个项目中是如何使用的？如果做其他项目，你会考虑怎么用？"><a href="#kafka在这个项目中是如何使用的？如果做其他项目，你会考虑怎么用？" class="headerlink" title="kafka在这个项目中是如何使用的？如果做其他项目，你会考虑怎么用？"></a>kafka在这个项目中是如何使用的？如果做其他项目，你会考虑怎么用？</h3><p>在这个项目中，kafka主要用来做站内通知，像对帖子进行点赞，评论，对用户私信和关注这些操作，都会给对应的用户发送系统通知。</p><p>kafka在这个系统的应用就是异步处理</p><p>比如点赞之后，执行完逻辑代码后，还需要像数据库中对应帖子信息表中保存系统消息内容，这个操作要进行io操作，是比较费时的，而点赞操作是一个需要页面快速做出反应的操作，这样就不太合理了，引入kafka之后，就可以将访问数据库的操作，交给kafka消费者线程去处理，进行点赞时，执行完redis点赞逻辑，发送消息给生产者线程，这时请求就可以返回了，不需要再进行等待数据库操作的完成。极大地提高了服务器的响应速度。</p><p>如果做其他项目，首先kafka有三个应用场景，应用解耦，异步处理，流量削峰</p><ul><li>应用解耦：再微服务架构中，可以用来做子系统见的消息通信，不过我没有具体实际操作过。</li><li>异步处理：发送邮件，发送短信之类的操作，都可以用来做异步处理。</li><li>流量削峰：主要应用再高并发系统的吧，具体我也没有做过这种情况的。</li></ul><h3 id="Redis是干什么的？在你的项目中都有哪里用到了？"><a href="#Redis是干什么的？在你的项目中都有哪里用到了？" class="headerlink" title="Redis是干什么的？在你的项目中都有哪里用到了？"></a>Redis是干什么的？在你的项目中都有哪里用到了？</h3><p>redis是内存数据库，支持多种数据接口的存储系统，可以用于缓存，事件发布或订阅，高速队列等场景。将一些热点数据存储再redis中，要用的时候直接从内存中取，极大地提高了速度，节约了服务器的开销。</p><ul><li>会话缓存（最常用）</li><li>消息队列（支付）</li><li>活动排行榜或计数</li><li>发布、订阅消息（消息通知）</li><li>商品列表，评论列表</li></ul><p>在我的项目中主要用来会话缓存，像一些常用的数据，比如说我项目中的推荐景点，可能很长时间都是这几个推荐的景点，如果每次访问，都去数据库中查的话，性能就会差，而且还会给数据库造成压力，所以我在第一次访问的时候将他们从数据库查出来之后存如redis，之后的访问直接从redis中取就可以了，除了推荐的景点，还会保存登录用户的相关信息和登录凭证、热门景点、热门帖子、帖子的点赞数量等一些数据。</p><h3 id="如何解决高并发向多个用户同时注册？"><a href="#如何解决高并发向多个用户同时注册？" class="headerlink" title="如何解决高并发向多个用户同时注册？"></a>如何解决高并发向多个用户同时注册？</h3><p>加锁，保证每次注册的时候都只有一个线程在进行注册。</p><h3 id="帖子评论在用户未登录的状态下可以评论吗？你是如何进行判断的？"><a href="#帖子评论在用户未登录的状态下可以评论吗？你是如何进行判断的？" class="headerlink" title="帖子评论在用户未登录的状态下可以评论吗？你是如何进行判断的？"></a>帖子评论在用户未登录的状态下可以评论吗？你是如何进行判断的？</h3><p>不可以，根据用户在redis中的登录凭证判断，如果redis中没有该用户，或者没有登录凭证，那就说明没有登录，就没办法评论。</p><h3 id="帖子评论中，-张三-评论了帖子，李四-可以评论-张三-吗？简述一下，数据库逻辑是如何实现得到？"><a href="#帖子评论中，-张三-评论了帖子，李四-可以评论-张三-吗？简述一下，数据库逻辑是如何实现得到？" class="headerlink" title="帖子评论中， 张三 评论了帖子，李四 可以评论 张三 吗？简述一下，数据库逻辑是如何实现得到？"></a>帖子评论中， 张三 评论了帖子，李四 可以评论 张三 吗？简述一下，数据库逻辑是如何实现得到？</h3><p>可以，数据库中的字段有from_id,to_id,评论类型，帖子id，内容等，from_id用户保存评论者的id，to_id则是被评论者的id，评论类型有评论和回复两种，如果是评论，那说明该评论是对于帖子的，而如果是回复，则是针对评论的。</p><h3 id="es全文搜索是如何添加数据的？"><a href="#es全文搜索是如何添加数据的？" class="headerlink" title="es全文搜索是如何添加数据的？"></a>es全文搜索是如何添加数据的？</h3><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="线程创建有几种方式？"><a href="#线程创建有几种方式？" class="headerlink" title="线程创建有几种方式？"></a>线程创建有几种方式？</h3><p>一共有四种方式：</p><ul><li>继承Thread类，重写run方法</li><li>实现runnable接口，重写run方法</li><li>实现callable接口，重写call方法</li><li>通过线程池创建线程</li></ul><h3 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h3><p>重载指的是方法的重载， 发生在同一个类之中，方法名相同，参数类型和参数个数不同，与返回值和访问修饰符无关</p><p>重写指的是子类对父类方法的重写，发生在继承关系之中，方法名和参数类型必须完全相同，与返回值无关，但必须是父类返回值的派生类，重写的方法访问修饰符必须大于或等于父类方法的修饰符，抛出的异常必须比父类更精确。</p><p>###final关键字的作用？</p><p>final可以作用在类，方法，变量上。</p><ul><li>类：表示该类不可被继承</li><li>方法：表示该类不可被重写</li><li>变量：表示该变量为常量，一点获得初始值就不可被改变</li></ul><h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h3><p>String类是一个不可变类，首选，该类被final修饰，也就是不能被继承，而内部采用字符数组来保存字符串，当然这个字符数组也被final修饰了，而且内部没有提供先关操作的其他方法，也就说字符串一旦确定就不能更改了，这导致String类是一个不可变的类，字符串改变基本上都会创建一个新的对象，当然有几种情况例外，String类因为是不可变的，如果每次创建字符串都创建一个对象的话，就太消耗资源了，因此String类有一个常量池，如果创建一个字符串，该字符串就会被放入到常量池中，如果之后又创建了一个新的字符串，那么就会首选去常量池中寻找，如果有该字符串就直接拿来使用了，如果没有就创建放入到常量池中，当然如果使用new关键字去创建字符串，无论常量池中是否有该字符串，都会创建一个新的字符串，如果采用String类进行字符串拼接的话，单纯的字面量拼接可以视为一个字符串，如果涉及到了变量拼接，那么就会在常量池中创建新的字符串了。</p><p>至于String类为何设计为不可变，主要从安全性和线程上考虑，字符串是最常用的类型了，经常会用他保存一些敏感数据，比如账号，密码，如果String是可变的，那么之后收到的String就是不可信任的了，而String类设计为不可变的，天生就是线程安全的，只要String被改变，就会创建一个新的字符串，对原有的字符串没有影响。</p><p>StringBuilder和StringBuffer是可变的字符串类，他们两个的区别主要就是StringBuilder不是线程安全的，而StringBuffer是线程安全的，他们两个类内部的方法基本上都是一样的，StringBuilder内部提供了对于字符串操作的一些方法，比如append方法用于拼接字符串。当然因为StringBuilder不是线程安全的，所以他的性能肯定是更好一些的。</p><p>如果需要大量的拼接字符串，应该首先考虑使用StringBuilder类，如果设计到线程安全，就使用StringBuffer类，如果字符串拼接数据量很小，直接使用String类就可以了。</p><h3 id="ArrayList和LinkedList的区别？"><a href="#ArrayList和LinkedList的区别？" class="headerlink" title="ArrayList和LinkedList的区别？"></a>ArrayList和LinkedList的区别？</h3><ul><li>ArrayList与LinkedList都实现了List接口，但是LinkedList多实现了一个Deque接口，所以LinkedList也可以当做队列使用</li><li>ArrayList与LinkedList的底层数据结构不同，ArrayList底层是基于动态数组实现的，而LinkedList是基于链表实现的</li><li>因为底层数据结构的不同，ArrayList与LinkedList的应用场景也不同，ArrayList更加适合查询数据，而LinkedList更加适合添加、删除、修改操作</li></ul><blockquote><p>ArrayList进行添加操作时，如果添加的位置有元素，那么该元素将后移，该元素后面的元素都向后移动，所以进行添加元素时，效率相对不高</p><p>LinkedList添加元素时，如果当前位置有元素，那么将遍历链表，找到指定位置的元素，然后添加，如果数据量较大，可能会遍历很多元素才能找到指定位置的元素，因此LinkedList在数据量不是很大时，添加操作的效率更高一些</p></blockquote><h3 id="String类中的常用方法"><a href="#String类中的常用方法" class="headerlink" title="String类中的常用方法"></a>String类中的常用方法</h3><ul><li>charAt(int index):返回 char指定索引处的值。</li><li>substring(int beginIndex, int endIndex):返回一个字符串，该字符串是此字符串的子字符串。</li><li>split(String regex):将此字符串分割为给定的 regular expression的匹配。</li><li>indexOf(String str):返回指定子字符串第一次出现的字符串内的索引。</li><li>lastIndexOf(String str):返回指定子字符串最后一次出现的字符串中的索引。</li><li>replace(char oldChar, char newChar):返回从替换所有出现的导致一个字符串 oldChar在此字符串 newChar</li><li>toLowerCase():将所有在此字符 String使用默认语言环境的规则，以小写。</li><li>toUpperCase():将所有在此字符 String使用默认语言环境的规则大写。</li><li>trim():返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。</li><li>length():返回此字符串的长度。</li><li>isEmpty():返回 true如果，且仅当 length()为 0 。</li><li>equals(Object anObject):将此字符串与指定对象进行比较。</li></ul><h3 id="Java的两种异常"><a href="#Java的两种异常" class="headerlink" title="Java的两种异常"></a>Java的两种异常</h3><ul><li>Error</li><li>Exception<ul><li>RuntimeException(运行时异常，又称为非受检异常)</li><li>CheckedException（编译时异常，又称为受检异常）</li></ul></li></ul><p>提示</p><p>不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。</p><h3 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h3><p>session存在服务器端，cookie存在客户端</p><h3 id="ajax的实现原理和实现过程"><a href="#ajax的实现原理和实现过程" class="headerlink" title="ajax的实现原理和实现过程"></a>ajax的实现原理和实现过程</h3><ul><li>实现原理</li><li>实现过程：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(</span><br><span class="line">    <span class="attr">url</span>:</span><br><span class="line">    <span class="attr">method</span>: </span><br><span class="line">    <span class="attr">data</span>: </span><br><span class="line">    <span class="attr">name</span>:</span><br><span class="line">    <span class="attr">success</span>:</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="判断一个对象是否是数字"><a href="#判断一个对象是否是数字" class="headerlink" title="判断一个对象是否是数字"></a>判断一个对象是否是数字</h3><p>可以使用Integer中的parseInt方法，如果出现异常，说明不是数字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.parseInt(value);</span><br></pre></td></tr></table></figure><h3 id="对一个数组进行排序并去掉重复项"><a href="#对一个数组进行排序并去掉重复项" class="headerlink" title="对一个数组进行排序并去掉重复项"></a>对一个数组进行排序并去掉重复项</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer [] removeDuplicatesAndSort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">//如果数组大小为0，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环遍历数组nums</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            <span class="comment">//判断元素是否存在，不存在则添加</span></span><br><span class="line">            <span class="keyword">if</span> (!list.contains(nums[i])) &#123;</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将list转为数组</span></span><br><span class="line">    Integer[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()]);</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    Arrays.sort(array);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序输出结果"><a href="#程序输出结果" class="headerlink" title="程序输出结果"></a>程序输出结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">createMap</span> <span class="params">(Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;C:&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;AB:&quot;</span> + map);</span><br><span class="line">        System.out.println(<span class="string">&quot;C:&quot;</span> + createMap(map));</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">12</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果： AB:{A&#x3D;1, B&#x3D;2} C:{A&#x3D;1, B&#x3D;2, C&#x3D;3} result:{A&#x3D;1, B&#x3D;2, C&#x3D;3} [1,12] [a,2]</p></blockquote><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="说一下bean的生命周期"><a href="#说一下bean的生命周期" class="headerlink" title="说一下bean的生命周期"></a>说一下bean的生命周期</h3><p>SpringBean 的生命周期主要有四个步骤： 创建，依赖注入，初始化，销毁</p><p>详细流程：</p><ol><li>Spring通过loadBeanDefinitions方法，通过xml或者注解扫描等方式将定义的Bean类全部找到，然后将其放入beanDefinitionMap集合中，然后遍历，在遍历的过程中通过createBean方法创建bean对象。</li><li>依赖注入是通过populateBean方法为Bean内部的属性进行赋值，通常是带有@Autowired注解的变量（会涉及到三级缓存解决循环依赖问题）。</li><li>通过InitializeBean进行初始化工作，执行初始化操作前会处理一系列的Aware接口，为对象扩展属性。如果bean实现了InitializeBean接口，则也会调用afterPropertiesSet方法完成初始化。之后会执行@Bean上自定义的initMethod方法，在该方法前后还需要处理Bean的各种后置处理器。之后将bean放入Singleton单例对象池中，对象就可以被使用了。</li><li>最后就是销毁，销毁前，会执行一些方法，如@PreDestory标识的方法，自定义的destroyMethod方法。</li></ol><p>产生</p><ul><li><p>开发人员命令spring启动时开始，启动开始时，通过加载<code>Bean定义loadBeanDefinitions方法</code>，用<code>xml，注解扫描</code>等各种方式，将定义的Bean类全部找到，并将其放入到容器中的一个<code>Bean定义集合beanDefinitionMap</code>中。有了这些Bean定义的集合后，就可以遍历这个集合，然后<code>通过createBean方法</code>创建这些Bean对象。</p></li><li><p>创建Bean对象大致分为<code>构造对象（实例化）、填充属性、初始化实例、注册销毁</code>四个步骤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 构造对象：`通过createBeanInstance方法`进行对象构造，先用`反射机制从Bean定义中的BeanClass`拿到这个类的构造方法。之后准备构造方法需要的参数，`通过Spring内部的单例池`中根据参数的Class类进行查找（如果这个类具有多个实例，则会通过参数名进行查找；如果没有找到，则认为构造信息不完整而抛出异常），参数准备好后就可以`通过反射进行Bean的构造`了（也就是常说的实例化），如果选择的是无参构造，则无需参数，直接构造就行了</span><br><span class="line">  </span><br><span class="line">&gt; * 如果获取构造方法时，这个方法只有一个构造方法，那就只能拿这一个，但如果Bean中有多个构造方法时，则会先拿带有@Autowired注解的构造方法，如果多个构造方法都带有@Autowired注解，那个Spring容器将无法判断到底用哪一个，将会抛出异常；如果构造方法都没有带@Autowired注解，那么会优先选用无入参构造方法；如果多个构造方法都无入参，Spring容器无法判断选用哪一个，那就会抛出异常</span><br><span class="line">&gt; * 不建议在任何Bean中添加多个构造方法，会导致可读性差，不易理解，维护也会很困难</span><br><span class="line">  </span><br><span class="line">* 属性填充：在Bean对象构造成功后，就可以进行属性填充了，`通过populateBean方法`为Bean内部的所需的属性进行赋值填充，通常就是带有@AutoWired注解的变量，会通过三级缓存机制进行填充（也就是所谓的依赖注入）</span><br><span class="line">  </span><br><span class="line">* 初始化实例：属性填充后，就要`通过InitializeBean方法`对实例进行初始化了。初始化的第一步是初始化容器的相关信息，通过`invokeAwareMethods`方法，为实现了`Aware接口的Bean设置诸如beanName，beanFactory等`容器信息，之后`通过invokeInitMethods方法执行Bean的初始化方法`。这个方法设计开发人员通过实现InitializeBean接口而实现的`afterPropertiesSet`方法。在`afterPropertiesSet`方法执行后，还会继续执行开发人员在Bean上自定义的initMethod方法，在执行初始化方法之前和之后还需要对`Bean后置处理器BeanPostProcessors`进行处理，Spring通过applyBeanProcessorsBeforeInitialization、applyBeanProcessorsAfterInitialization分别在初始化之前和之后处理各种Bean的后置处理器，处理器包括Spring提供的负责AOP处理的AnnotationAwareAspectJAutoProxyCreator、负责构造后@PostConstruct和销毁前@PreDestroy处理的InitDestroyAnnatationBeanPostProcessor等系统级处理器，以及开发人员通过是实现BeanPostProcessor接口的自定义处理器，这些处理器很多，可以通过实现PriorityOrdered接口指定顺序进行逐一处理</span><br><span class="line">  </span><br><span class="line">&gt; * Aware接口代表信息感知接口，一旦实现了该接口，就可以在bean实例中感知并获取到对应的信息</span><br><span class="line">  </span><br><span class="line">* 注册销毁：以上步骤完成后Bean实例就已经可用了，为了让Bean销毁，Spring通过注册销毁registerDisposableBean方法将实现了销毁接口DisposableBean的Bean进行注册，这样在销毁时就可以执行destroy方法了</span><br></pre></td></tr></table></figure></li><li><p>通过以上四步Bean就被创建好了，之后只需要将这些bean对象通过addSingleton方法放入单例池singletonObjects中就可以被获取和使用了，至此产生Bean就全部完成了，之后开发人员就可以使用这些Bean了</p></li></ul><p>使用</p><p>销毁</p><ul><li>最后执行close方法之后，在销毁之前需要先执行销毁前处理器postProcessBeforeDestruction，这里会执行Bean中@PreDestroy注解的方法，然后通过destroyBeans方法逐一销毁Spring中所有的Bean，销毁时会执行destroy方法，destroy方法执行之后，会通过客户销毁方法invokeCustomDestroyMethod来执行开发人员在Bean上自定义的destroyMethod方法</li></ul><h3 id="说一下aop的应用场景"><a href="#说一下aop的应用场景" class="headerlink" title="说一下aop的应用场景"></a>说一下aop的应用场景</h3><p>aop应用场景：</p><ul><li>日志</li><li>权限校验</li><li>性能监控</li><li>事务处理</li></ul><h3 id="简述一下ioc"><a href="#简述一下ioc" class="headerlink" title="简述一下ioc"></a>简述一下ioc</h3><p>ioc主要是控制反转，就是说将创建对象的控制权交给ioc容器去创建并且管理，并且有ioc容器完成对象的注入，这样就可以简化应用的开发，将应用从复杂的依赖关系中解放出来，ioc容器就像一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件或者注解就可以了，不需要考虑对象如何被创建的。</p><p>spring ioc的实现原理主要是通过工厂模式加上反射机制实现的</p><h3 id="说一下springmvc的执行流程"><a href="#说一下springmvc的执行流程" class="headerlink" title="说一下springmvc的执行流程"></a>说一下springmvc的执行流程</h3><p><img src="http://rtxzwq33o.hn-bkt.clouddn.com/img/springmvc.png" alt="springmvc的执行流程"></p><h3 id="SpringBoot如何实现热部署的？"><a href="#SpringBoot如何实现热部署的？" class="headerlink" title="SpringBoot如何实现热部署的？"></a>SpringBoot如何实现热部署的？</h3><ul><li><p>模板热部署：在SpringBoot中，模板引擎的页面默认是开启缓存的，如果修改了页面的内容，则刷新页面是得不到修改后的页面的，因此我们可以在application.properties中关闭模版引擎的缓存</p></li><li><p>使用调试模式Debug实现热部署：此种方式为最简单最快速的一种热部署方式，运行系统时使用Debug模式，无需装任何插件即可，但是无发对配置文件，方法名称改变，增加类及方法进行热部署，使用范围有限</p></li><li><p>spring-boot-devtools：在SpringBoot项目中添加spring-boot-devtools依赖即可实现页面和代码的热部署</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>此种方式的特点是作用范围广，系统的任何变动包括配置文件修改、方法名称变化都能覆盖，但是后遗症也非常明显，它是采用文件变化后重启的策略来实现了，主要是节省了我们手动点击重启的时间，提高了实效性，在体验上会稍差。 spring-boot-devtools 默认关闭了模版缓存，如果使用这种方式不用单独配置关闭模版缓存</p></blockquote></li><li><p>spring loaded：此种方式与Debug模式类似，适用范围有限，但是不依赖于Debug模式启动，通过Spring Loaded库文件启动，即可在正常模式下进行实时热部署。此种需要在 run configuration 中进行配置。</p></li><li><p>jrebel：Jrebel是Java开发最好的热部署工具，对Spring Boot 提供了极佳的支持，JRebel为收费软件，试用期14天。，可直接通过插件安装</p></li></ul><h3 id="SpringBean的作用域？"><a href="#SpringBean的作用域？" class="headerlink" title="SpringBean的作用域？"></a>SpringBean的作用域？</h3><p>spring bean有五中作用域</p><ul><li>singleton：spring bean默认是单例的</li><li>prototype：每次请求都会创建一个新的bean</li><li>request：每次http请求都会创建一个新的bean，这个bean只在同一个http的request中有效</li><li>session：每次http请求都会创建一个信息的bean，这个bean只在同一个http的session中有效</li><li>global-session，全局作用域，但是在spring5中取消了</li></ul><h3 id="spring事务的隔离级别？"><a href="#spring事务的隔离级别？" class="headerlink" title="spring事务的隔离级别？"></a>spring事务的隔离级别？</h3><p>一共有五中隔离级别：</p><ul><li>default：默认的隔离级别，和数据库有关，mysql默认的隔离级别是重复读，而默认的隔离级别是已提交读</li><li>uncommitted：允许读取未提交的数据，可能导致脏读，幻读和不可重复读</li><li>committed：允许读取已提交的数据，可以阻止脏读，但幻读和不可重复读仍然可能发生</li><li>read：可重复读，多次读取的数据都是一致的，可以避免脏读和不可重读读，但幻读仍可能发生</li><li>serializable：最高的隔离级别，所有的事务都是一个一个进行的，可以有效地阻止脏读，幻读，不可重复读，但是十分的影响性能，开发中一般也不会使用到这个级别</li></ul><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="mybatis的执行器有哪些？"><a href="#mybatis的执行器有哪些？" class="headerlink" title="mybatis的执行器有哪些？"></a>mybatis的执行器有哪些？</h3><p>Mybatis共有三种基本的Executor执行器：</p><ul><li>SimpleExecutor：每次执行一个select或update，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置Map&lt;String, Statement&gt;内，供下一次使用。简而言之就是重复使用Statement对象。</li><li>BatchExecutor：执行update，将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等到逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><h3 id="Mybatis的逻辑分页和物理分页？"><a href="#Mybatis的逻辑分页和物理分页？" class="headerlink" title="Mybatis的逻辑分页和物理分页？"></a>Mybatis的逻辑分页和物理分页？</h3><p>物理分页：物理分页就是依赖数据库本身提供的分页方式，如MySQL的limit，好处是效率比较高，但是比较依赖数据库，如果是不同的数据库，会有不同的写法。</p><p>逻辑分页：逻辑分页是利用游标分页，好处是对所有数据库都适用，但是效率低。可以使用Mybatis自带的RowBounds进行逻辑分页，它一次查询很多数据，然后在数据中再进行检索。</p><h3 id="Mybatis一级缓存和二级缓存？"><a href="#Mybatis一级缓存和二级缓存？" class="headerlink" title="Mybatis一级缓存和二级缓存？"></a>Mybatis一级缓存和二级缓存？</h3><p>一级缓存：一级缓存是<code>SqlSession</code>级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</p><blockquote><p>一级缓存失效的四种情况：</p><ol><li>不同的SqlSession对应不同的一级缓存</li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li></ol></blockquote><p>二级缓存：二级缓存是<code>SqlSessionFactory</code>级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p><blockquote><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置全局配置属性<code>cacheEnabled=&quot;true&quot;</code>，默认为true，不需要设置</li><li>在映射文件中设置标签<code>&lt;cache /&gt;</code></li><li>二级缓存必须在<code>SqlSession关闭或提交之后有效</code></li><li>查询的数据所转换的实体类类型必须<code>实现序列化的接口Serializable</code></li></ol><p>二级缓存失效的情况：</p><ul><li>两次查询之间执行了任意地增删改，会使一级和二级缓存同时失效</li></ul></blockquote><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="如何预防和处理死锁？"><a href="#如何预防和处理死锁？" class="headerlink" title="如何预防和处理死锁？"></a>如何预防和处理死锁？</h3><p><strong>预防死锁：</strong></p><p>预防死锁的方法是通过破坏产生死锁的四个必要条件中的一个或几个，避免发生死锁</p><p>由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证</p><ul><li>破坏请求和保持条件</li></ul><p>为了能破坏请求和保持条件，系统必须保证做到：当一个进程在请求资源时，它不能持有不可抢占资源</p><p>可以通过下面两个协议实现：</p><p>第一种协议：所有进程在运行之前，一次性申请其所需要的全部资源，如果系统有足够的资源分配给某进程，便把它所需要的所有资源分配给它，这样该进程在运行期间就不会再提出资源请求，从而破坏了请求条件；系统中只要有一种资源不能满足进程的要求，即使其他所需要的资源都空闲也不会分配给该进程，由于该进程在等待期间没有占用任何资源，从而破坏了保持条件，从而可以预防死锁的发生</p><p>优点：简单、易行、安全</p><p>缺点：资源被严重浪费，严重地降低了资源的利用率，进程在开始运行时就一次性地占用了整个运行过程所需的全部资源</p><p>使进程经常发生饥饿现象，因为仅当进程在获得了所需的全部资源后才会开始运行，这样就可能由于个别资源长期被其他进程占用，导致等待该资源的进程迟迟不能开始运行</p><p>第二种协议：这个协议是对第一种协议的改进，它允许一个进程只获得运行初期所需要的资源后，便开始运行，在运行过程中再逐步释放已经分配给自己并且已经用完的全部资源，然后再请求新的资源</p><p>优点：使进程更快地完成任务，提高设备的利用率，还可以减少进程发生饥饿的几率</p><ul><li>破坏不可抢占条件</li></ul><p>协议中规定：当一个进程已经保持了某些不可被抢占资源，又提出了新的资源请求不能得到满足时，它必须释放已经保持的所有资源，等到以后需要时再重新申请，这就意味着进程已占有的资源会被暂地的释放，这样就破坏了不可抢占条件</p><ul><li>破坏循环等待条件</li></ul><p>对系统中所有资源类型进行线性排序，并赋予不同的序号。然后采用这样的预防协议：规定每个进程必须按序号递增的顺序请求资源。一个进程在开始时，可以请求某类资源的单元，以后当且仅当F(Rj)&gt;F(Ri)时，进程才可以请求资源Rj的单元。如果需要多个同类资源单元， 则必须一起请求</p><p>采用这种策略，如何规定每种资源的序号十分重要，通常根据大多数进程需要资源的先后顺序来确定</p><p><strong>处理死锁：</strong></p><p>常用地解除死锁的两种方法是：</p><ul><li>抢占资源，从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态</li><li>终止进程，终止系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> Mybatis </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
